// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const countJobs = `-- name: CountJobs :one
SELECT COUNT(*) FROM jobs
`

func (q *Queries) CountJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*) FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPackages = `-- name: CountPackages :one

SELECT COUNT(*) FROM packages
`

// Admin queries
func (q *Queries) CountPackages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPackages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPosts = `-- name: CountPosts :one
SELECT COUNT(*) FROM posts
`

func (q *Queries) CountPosts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPosts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReviews = `-- name: CountReviews :one
SELECT COUNT(*) FROM reviews
`

func (q *Queries) CountReviews(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countReviews)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVehicles = `-- name: CountVehicles :one
SELECT COUNT(*) FROM vehicles
`

func (q *Queries) CountVehicles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVehicles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPackage = `-- name: CreatePackage :one
INSERT INTO packages (slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at
`

type CreatePackageParams struct {
	Slug        string         `json:"slug"`
	Name        string         `json:"name"`
	ShortDesc   sql.NullString `json:"short_desc"`
	LongDesc    sql.NullString `json:"long_desc"`
	PriceMin    sql.NullInt64  `json:"price_min"`
	PriceMax    sql.NullInt64  `json:"price_max"`
	DurationEst sql.NullInt64  `json:"duration_est"`
	IsActive    sql.NullBool   `json:"is_active"`
	SortOrder   sql.NullInt64  `json:"sort_order"`
}

func (q *Queries) CreatePackage(ctx context.Context, arg CreatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, createPackage,
		arg.Slug,
		arg.Name,
		arg.ShortDesc,
		arg.LongDesc,
		arg.PriceMin,
		arg.PriceMax,
		arg.DurationEst,
		arg.IsActive,
		arg.SortOrder,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePackage = `-- name: DeletePackage :exec
DELETE FROM packages WHERE id = ?
`

func (q *Queries) DeletePackage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePackage, id)
	return err
}

const getAllPackages = `-- name: GetAllPackages :many
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE is_active = 1
ORDER BY sort_order, id
`

func (q *Queries) GetAllPackages(ctx context.Context) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, getAllPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.ShortDesc,
			&i.LongDesc,
			&i.PriceMin,
			&i.PriceMax,
			&i.DurationEst,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPackagesAdmin = `-- name: GetAllPackagesAdmin :many
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
ORDER BY sort_order, id
`

func (q *Queries) GetAllPackagesAdmin(ctx context.Context) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, getAllPackagesAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.ShortDesc,
			&i.LongDesc,
			&i.PriceMin,
			&i.PriceMax,
			&i.DurationEst,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, vehicle_id, package_id, technician, notes, completed_at, featured, display_price, created_at, updated_at FROM jobs WHERE id = ?
`

func (q *Queries) GetJobByID(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.VehicleID,
		&i.PackageID,
		&i.Technician,
		&i.Notes,
		&i.CompletedAt,
		&i.Featured,
		&i.DisplayPrice,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaForJob = `-- name: GetMediaForJob :many
SELECT id, job_id, vehicle_id, url, kind, sort_order, alt_text, created_at FROM media
WHERE job_id = ?
ORDER BY sort_order, id
`

func (q *Queries) GetMediaForJob(ctx context.Context, jobID sql.NullInt64) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getMediaForJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.VehicleID,
			&i.Url,
			&i.Kind,
			&i.SortOrder,
			&i.AltText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaForVehicle = `-- name: GetMediaForVehicle :many
SELECT id, job_id, vehicle_id, url, kind, sort_order, alt_text, created_at FROM media
WHERE vehicle_id = ?
ORDER BY sort_order, id
`

func (q *Queries) GetMediaForVehicle(ctx context.Context, vehicleID sql.NullInt64) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getMediaForVehicle, vehicleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.VehicleID,
			&i.Url,
			&i.Kind,
			&i.SortOrder,
			&i.AltText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPackageByID = `-- name: GetPackageByID :one
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE id = ? LIMIT 1
`

func (q *Queries) GetPackageByID(ctx context.Context, id int64) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageByID, id)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPackageBySlug = `-- name: GetPackageBySlug :one
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetPackageBySlug(ctx context.Context, slug string) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageBySlug, slug)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostBySlug = `-- name: GetPostBySlug :one
SELECT id, slug, title, excerpt, body, author, published_at, created_at, updated_at FROM posts
WHERE slug = ? AND published_at IS NOT NULL LIMIT 1
`

func (q *Queries) GetPostBySlug(ctx context.Context, slug string) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostBySlug, slug)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Excerpt,
		&i.Body,
		&i.Author,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicleBySlug = `-- name: GetVehicleBySlug :one
SELECT id, slug, vin, year, make, model, trim, price, stock_number, dealership_listing_url, status, posted_at, created_at, updated_at FROM vehicles
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetVehicleBySlug(ctx context.Context, slug string) (Vehicle, error) {
	row := q.db.QueryRowContext(ctx, getVehicleBySlug, slug)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Vin,
		&i.Year,
		&i.Make,
		&i.Model,
		&i.Trim,
		&i.Price,
		&i.StockNumber,
		&i.DealershipListingUrl,
		&i.Status,
		&i.PostedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFeaturedJobs = `-- name: ListFeaturedJobs :many
SELECT j.id, j.vehicle_id, j.package_id, j.technician, j.notes, j.completed_at, j.featured, j.display_price, j.created_at, j.updated_at, v.make, v.model, v.year, v.slug as vehicle_slug
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
WHERE j.featured = 1
ORDER BY j.completed_at DESC
LIMIT ?
`

type ListFeaturedJobsRow struct {
	ID           int64          `json:"id"`
	VehicleID    sql.NullInt64  `json:"vehicle_id"`
	PackageID    sql.NullInt64  `json:"package_id"`
	Technician   sql.NullString `json:"technician"`
	Notes        sql.NullString `json:"notes"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	Featured     sql.NullBool   `json:"featured"`
	DisplayPrice sql.NullInt64  `json:"display_price"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	Make         sql.NullString `json:"make"`
	Model        sql.NullString `json:"model"`
	Year         sql.NullInt64  `json:"year"`
	VehicleSlug  sql.NullString `json:"vehicle_slug"`
}

func (q *Queries) ListFeaturedJobs(ctx context.Context, limit int64) ([]ListFeaturedJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeaturedJobsRow
	for rows.Next() {
		var i ListFeaturedJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.PackageID,
			&i.Technician,
			&i.Notes,
			&i.CompletedAt,
			&i.Featured,
			&i.DisplayPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.VehicleSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedReviews = `-- name: ListFeaturedReviews :many
SELECT id, author, rating, body, source, is_featured, created_at FROM reviews
WHERE is_featured = 1
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListFeaturedReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Rating,
			&i.Body,
			&i.Source,
			&i.IsFeatured,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobs = `-- name: ListJobs :many
SELECT j.id, j.vehicle_id, j.package_id, j.technician, j.notes, j.completed_at, j.featured, j.display_price, j.created_at, j.updated_at, v.make, v.model, v.year, v.slug as vehicle_slug
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
ORDER BY j.completed_at DESC
LIMIT ? OFFSET ?
`

type ListJobsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListJobsRow struct {
	ID           int64          `json:"id"`
	VehicleID    sql.NullInt64  `json:"vehicle_id"`
	PackageID    sql.NullInt64  `json:"package_id"`
	Technician   sql.NullString `json:"technician"`
	Notes        sql.NullString `json:"notes"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	Featured     sql.NullBool   `json:"featured"`
	DisplayPrice sql.NullInt64  `json:"display_price"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	Make         sql.NullString `json:"make"`
	Model        sql.NullString `json:"model"`
	Year         sql.NullInt64  `json:"year"`
	VehicleSlug  sql.NullString `json:"vehicle_slug"`
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]ListJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsRow
	for rows.Next() {
		var i ListJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.VehicleID,
			&i.PackageID,
			&i.Technician,
			&i.Notes,
			&i.CompletedAt,
			&i.Featured,
			&i.DisplayPrice,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.VehicleSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
SELECT id, slug, title, excerpt, body, author, published_at, created_at, updated_at FROM posts
WHERE published_at IS NOT NULL
ORDER BY published_at DESC
LIMIT ? OFFSET ?
`

type ListPostsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, listPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Excerpt,
			&i.Body,
			&i.Author,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviews = `-- name: ListReviews :many
SELECT id, author, rating, body, source, is_featured, created_at FROM reviews
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, listReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Rating,
			&i.Body,
			&i.Source,
			&i.IsFeatured,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePackage = `-- name: UpdatePackage :one
UPDATE packages
SET slug = ?, name = ?, short_desc = ?, long_desc = ?, price_min = ?, price_max = ?, duration_est = ?, is_active = ?, sort_order = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at
`

type UpdatePackageParams struct {
	Slug        string         `json:"slug"`
	Name        string         `json:"name"`
	ShortDesc   sql.NullString `json:"short_desc"`
	LongDesc    sql.NullString `json:"long_desc"`
	PriceMin    sql.NullInt64  `json:"price_min"`
	PriceMax    sql.NullInt64  `json:"price_max"`
	DurationEst sql.NullInt64  `json:"duration_est"`
	IsActive    sql.NullBool   `json:"is_active"`
	SortOrder   sql.NullInt64  `json:"sort_order"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdatePackage(ctx context.Context, arg UpdatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, updatePackage,
		arg.Slug,
		arg.Name,
		arg.ShortDesc,
		arg.LongDesc,
		arg.PriceMin,
		arg.PriceMax,
		arg.DurationEst,
		arg.IsActive,
		arg.SortOrder,
		arg.ID,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
