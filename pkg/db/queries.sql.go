// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const countJobs = `-- name: CountJobs :one
SELECT COUNT(*) FROM jobs
`

func (q *Queries) CountJobs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*) FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPackages = `-- name: CountPackages :one

SELECT COUNT(*) FROM packages
`

// Admin queries
func (q *Queries) CountPackages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPackages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPosts = `-- name: CountPosts :one
SELECT COUNT(*) FROM posts
`

func (q *Queries) CountPosts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPosts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReviews = `-- name: CountReviews :one
SELECT COUNT(*) FROM reviews
`

func (q *Queries) CountReviews(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countReviews)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countVehicles = `-- name: CountVehicles :one
SELECT COUNT(*) FROM vehicles
`

func (q *Queries) CountVehicles(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countVehicles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPackage = `-- name: CreatePackage :one
INSERT INTO packages (slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at
`

type CreatePackageParams struct {
	Slug        string         `json:"slug"`
	Name        string         `json:"name"`
	ShortDesc   sql.NullString `json:"short_desc"`
	LongDesc    sql.NullString `json:"long_desc"`
	PriceMin    sql.NullInt64  `json:"price_min"`
	PriceMax    sql.NullInt64  `json:"price_max"`
	DurationEst sql.NullInt64  `json:"duration_est"`
	IsActive    sql.NullBool   `json:"is_active"`
	SortOrder   sql.NullInt64  `json:"sort_order"`
}

func (q *Queries) CreatePackage(ctx context.Context, arg CreatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, createPackage,
		arg.Slug,
		arg.Name,
		arg.ShortDesc,
		arg.LongDesc,
		arg.PriceMin,
		arg.PriceMax,
		arg.DurationEst,
		arg.IsActive,
		arg.SortOrder,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePackage = `-- name: DeletePackage :exec
DELETE FROM packages WHERE id = ?
`

func (q *Queries) DeletePackage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePackage, id)
	return err
}

const getAllPackages = `-- name: GetAllPackages :many
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE is_active = 1
ORDER BY sort_order, id
`

func (q *Queries) GetAllPackages(ctx context.Context) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, getAllPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.ShortDesc,
			&i.LongDesc,
			&i.PriceMin,
			&i.PriceMax,
			&i.DurationEst,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPackagesAdmin = `-- name: GetAllPackagesAdmin :many
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
ORDER BY sort_order, id
`

func (q *Queries) GetAllPackagesAdmin(ctx context.Context) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, getAllPackagesAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.ShortDesc,
			&i.LongDesc,
			&i.PriceMin,
			&i.PriceMax,
			&i.DurationEst,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFeaturedWork = `-- name: GetFeaturedWork :many
SELECT
    j.id,
    j.slug,
    j.featured,
    j.highlight_text,
    j.display_price,
    j.completed_at,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.trim as vehicle_trim,
    v.dealership_name,
    p.name as package_name
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
LEFT JOIN packages p ON j.package_id = p.id
WHERE j.featured = 1 AND j.completed_at IS NOT NULL
ORDER BY j.completed_at DESC
LIMIT ?
`

type GetFeaturedWorkRow struct {
	ID             int64          `json:"id"`
	Slug           sql.NullString `json:"slug"`
	Featured       sql.NullBool   `json:"featured"`
	HighlightText  sql.NullString `json:"highlight_text"`
	DisplayPrice   sql.NullInt64  `json:"display_price"`
	CompletedAt    sql.NullTime   `json:"completed_at"`
	VehicleYear    sql.NullInt64  `json:"vehicle_year"`
	VehicleMake    sql.NullString `json:"vehicle_make"`
	VehicleModel   sql.NullString `json:"vehicle_model"`
	VehicleTrim    sql.NullString `json:"vehicle_trim"`
	DealershipName sql.NullString `json:"dealership_name"`
	PackageName    sql.NullString `json:"package_name"`
}

func (q *Queries) GetFeaturedWork(ctx context.Context, limit int64) ([]GetFeaturedWorkRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeaturedWork, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeaturedWorkRow
	for rows.Next() {
		var i GetFeaturedWorkRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Featured,
			&i.HighlightText,
			&i.DisplayPrice,
			&i.CompletedAt,
			&i.VehicleYear,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.VehicleTrim,
			&i.DealershipName,
			&i.PackageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, slug, vehicle_id, package_id, technician, notes, completed_at, duration_actual, featured, display_price, highlight_text, customer_testimonial, customer_name, meta_description, meta_keywords, created_at, updated_at FROM jobs WHERE id = ?
`

func (q *Queries) GetJobByID(ctx context.Context, id int64) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.VehicleID,
		&i.PackageID,
		&i.Technician,
		&i.Notes,
		&i.CompletedAt,
		&i.DurationActual,
		&i.Featured,
		&i.DisplayPrice,
		&i.HighlightText,
		&i.CustomerTestimonial,
		&i.CustomerName,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMediaForJob = `-- name: GetMediaForJob :many
SELECT id, job_id, vehicle_id, url, kind, sort_order, alt_text, created_at FROM media
WHERE job_id = ?
ORDER BY sort_order, id
`

func (q *Queries) GetMediaForJob(ctx context.Context, jobID sql.NullInt64) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getMediaForJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.VehicleID,
			&i.Url,
			&i.Kind,
			&i.SortOrder,
			&i.AltText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMediaForVehicle = `-- name: GetMediaForVehicle :many
SELECT id, job_id, vehicle_id, url, kind, sort_order, alt_text, created_at FROM media
WHERE vehicle_id = ?
ORDER BY sort_order, id
`

func (q *Queries) GetMediaForVehicle(ctx context.Context, vehicleID sql.NullInt64) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getMediaForVehicle, vehicleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.VehicleID,
			&i.Url,
			&i.Kind,
			&i.SortOrder,
			&i.AltText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPackageByID = `-- name: GetPackageByID :one
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE id = ? LIMIT 1
`

func (q *Queries) GetPackageByID(ctx context.Context, id int64) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageByID, id)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPackageBySlug = `-- name: GetPackageBySlug :one
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetPackageBySlug(ctx context.Context, slug string) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageBySlug, slug)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostBySlug = `-- name: GetPostBySlug :one
SELECT id, slug, title, excerpt, body, author, published_at, created_at, updated_at FROM posts
WHERE slug = ? AND published_at IS NOT NULL LIMIT 1
`

func (q *Queries) GetPostBySlug(ctx context.Context, slug string) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostBySlug, slug)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Excerpt,
		&i.Body,
		&i.Author,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRelatedWork = `-- name: GetRelatedWork :many
SELECT
    j.id,
    j.slug,
    j.featured,
    j.completed_at,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.dealership_name,
    p.name as package_name
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
LEFT JOIN packages p ON j.package_id = p.id
WHERE j.id != ?
  AND (v.make = ? OR j.package_id = ?)
  AND j.completed_at IS NOT NULL
ORDER BY j.featured DESC, j.completed_at DESC
LIMIT 3
`

type GetRelatedWorkParams struct {
	ID        int64         `json:"id"`
	Make      string        `json:"make"`
	PackageID sql.NullInt64 `json:"package_id"`
}

type GetRelatedWorkRow struct {
	ID             int64          `json:"id"`
	Slug           sql.NullString `json:"slug"`
	Featured       sql.NullBool   `json:"featured"`
	CompletedAt    sql.NullTime   `json:"completed_at"`
	VehicleYear    sql.NullInt64  `json:"vehicle_year"`
	VehicleMake    sql.NullString `json:"vehicle_make"`
	VehicleModel   sql.NullString `json:"vehicle_model"`
	DealershipName sql.NullString `json:"dealership_name"`
	PackageName    sql.NullString `json:"package_name"`
}

func (q *Queries) GetRelatedWork(ctx context.Context, arg GetRelatedWorkParams) ([]GetRelatedWorkRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedWork, arg.ID, arg.Make, arg.PackageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRelatedWorkRow
	for rows.Next() {
		var i GetRelatedWorkRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Featured,
			&i.CompletedAt,
			&i.VehicleYear,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.DealershipName,
			&i.PackageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehicleBySlug = `-- name: GetVehicleBySlug :one
SELECT id, slug, vin, year, make, model, trim, color, price, stock_number, dealership_name, dealership_logo_url, dealership_listing_url, dealership_location, status, posted_at, created_at, updated_at FROM vehicles
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetVehicleBySlug(ctx context.Context, slug string) (Vehicle, error) {
	row := q.db.QueryRowContext(ctx, getVehicleBySlug, slug)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Vin,
		&i.Year,
		&i.Make,
		&i.Model,
		&i.Trim,
		&i.Color,
		&i.Price,
		&i.StockNumber,
		&i.DealershipName,
		&i.DealershipLogoUrl,
		&i.DealershipListingUrl,
		&i.DealershipLocation,
		&i.Status,
		&i.PostedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkBySlug = `-- name: GetWorkBySlug :one

SELECT
    j.id, j.slug, j.vehicle_id, j.package_id, j.technician, j.notes, j.completed_at, j.duration_actual, j.featured, j.display_price, j.highlight_text, j.customer_testimonial, j.customer_name, j.meta_description, j.meta_keywords, j.created_at, j.updated_at,
    v.slug as vehicle_slug,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.trim as vehicle_trim,
    v.color as vehicle_color,
    v.dealership_name,
    v.dealership_logo_url,
    v.dealership_listing_url,
    v.dealership_location,
    p.name as package_name,
    p.short_desc as package_short_desc,
    p.price_min as package_price_min,
    p.price_max as package_price_max
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
LEFT JOIN packages p ON j.package_id = p.id
WHERE j.slug = ? LIMIT 1
`

type GetWorkBySlugRow struct {
	ID                   int64          `json:"id"`
	Slug                 sql.NullString `json:"slug"`
	VehicleID            sql.NullInt64  `json:"vehicle_id"`
	PackageID            sql.NullInt64  `json:"package_id"`
	Technician           sql.NullString `json:"technician"`
	Notes                sql.NullString `json:"notes"`
	CompletedAt          sql.NullTime   `json:"completed_at"`
	DurationActual       sql.NullInt64  `json:"duration_actual"`
	Featured             sql.NullBool   `json:"featured"`
	DisplayPrice         sql.NullInt64  `json:"display_price"`
	HighlightText        sql.NullString `json:"highlight_text"`
	CustomerTestimonial  sql.NullString `json:"customer_testimonial"`
	CustomerName         sql.NullString `json:"customer_name"`
	MetaDescription      sql.NullString `json:"meta_description"`
	MetaKeywords         sql.NullString `json:"meta_keywords"`
	CreatedAt            sql.NullTime   `json:"created_at"`
	UpdatedAt            sql.NullTime   `json:"updated_at"`
	VehicleSlug          sql.NullString `json:"vehicle_slug"`
	VehicleYear          sql.NullInt64  `json:"vehicle_year"`
	VehicleMake          sql.NullString `json:"vehicle_make"`
	VehicleModel         sql.NullString `json:"vehicle_model"`
	VehicleTrim          sql.NullString `json:"vehicle_trim"`
	VehicleColor         sql.NullString `json:"vehicle_color"`
	DealershipName       sql.NullString `json:"dealership_name"`
	DealershipLogoUrl    sql.NullString `json:"dealership_logo_url"`
	DealershipListingUrl sql.NullString `json:"dealership_listing_url"`
	DealershipLocation   sql.NullString `json:"dealership_location"`
	PackageName          sql.NullString `json:"package_name"`
	PackageShortDesc     sql.NullString `json:"package_short_desc"`
	PackagePriceMin      sql.NullInt64  `json:"package_price_min"`
	PackagePriceMax      sql.NullInt64  `json:"package_price_max"`
}

// Work/Portfolio queries
func (q *Queries) GetWorkBySlug(ctx context.Context, slug sql.NullString) (GetWorkBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getWorkBySlug, slug)
	var i GetWorkBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.VehicleID,
		&i.PackageID,
		&i.Technician,
		&i.Notes,
		&i.CompletedAt,
		&i.DurationActual,
		&i.Featured,
		&i.DisplayPrice,
		&i.HighlightText,
		&i.CustomerTestimonial,
		&i.CustomerName,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VehicleSlug,
		&i.VehicleYear,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleTrim,
		&i.VehicleColor,
		&i.DealershipName,
		&i.DealershipLogoUrl,
		&i.DealershipListingUrl,
		&i.DealershipLocation,
		&i.PackageName,
		&i.PackageShortDesc,
		&i.PackagePriceMin,
		&i.PackagePriceMax,
	)
	return i, err
}

const listAllWork = `-- name: ListAllWork :many
SELECT
    j.id,
    j.slug,
    j.featured,
    j.highlight_text,
    j.display_price,
    j.completed_at,
    v.year as vehicle_year,
    v.make as vehicle_make,
    v.model as vehicle_model,
    v.trim as vehicle_trim,
    v.dealership_name,
    p.name as package_name
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
LEFT JOIN packages p ON j.package_id = p.id
WHERE j.completed_at IS NOT NULL
ORDER BY j.completed_at DESC
LIMIT ? OFFSET ?
`

type ListAllWorkParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListAllWorkRow struct {
	ID             int64          `json:"id"`
	Slug           sql.NullString `json:"slug"`
	Featured       sql.NullBool   `json:"featured"`
	HighlightText  sql.NullString `json:"highlight_text"`
	DisplayPrice   sql.NullInt64  `json:"display_price"`
	CompletedAt    sql.NullTime   `json:"completed_at"`
	VehicleYear    sql.NullInt64  `json:"vehicle_year"`
	VehicleMake    sql.NullString `json:"vehicle_make"`
	VehicleModel   sql.NullString `json:"vehicle_model"`
	VehicleTrim    sql.NullString `json:"vehicle_trim"`
	DealershipName sql.NullString `json:"dealership_name"`
	PackageName    sql.NullString `json:"package_name"`
}

func (q *Queries) ListAllWork(ctx context.Context, arg ListAllWorkParams) ([]ListAllWorkRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllWork, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllWorkRow
	for rows.Next() {
		var i ListAllWorkRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Featured,
			&i.HighlightText,
			&i.DisplayPrice,
			&i.CompletedAt,
			&i.VehicleYear,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.VehicleTrim,
			&i.DealershipName,
			&i.PackageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedJobs = `-- name: ListFeaturedJobs :many
SELECT j.id, j.slug, j.vehicle_id, j.package_id, j.technician, j.notes, j.completed_at, j.duration_actual, j.featured, j.display_price, j.highlight_text, j.customer_testimonial, j.customer_name, j.meta_description, j.meta_keywords, j.created_at, j.updated_at, v.make, v.model, v.year, v.slug as vehicle_slug
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
WHERE j.featured = 1
ORDER BY j.completed_at DESC
LIMIT ?
`

type ListFeaturedJobsRow struct {
	ID                  int64          `json:"id"`
	Slug                sql.NullString `json:"slug"`
	VehicleID           sql.NullInt64  `json:"vehicle_id"`
	PackageID           sql.NullInt64  `json:"package_id"`
	Technician          sql.NullString `json:"technician"`
	Notes               sql.NullString `json:"notes"`
	CompletedAt         sql.NullTime   `json:"completed_at"`
	DurationActual      sql.NullInt64  `json:"duration_actual"`
	Featured            sql.NullBool   `json:"featured"`
	DisplayPrice        sql.NullInt64  `json:"display_price"`
	HighlightText       sql.NullString `json:"highlight_text"`
	CustomerTestimonial sql.NullString `json:"customer_testimonial"`
	CustomerName        sql.NullString `json:"customer_name"`
	MetaDescription     sql.NullString `json:"meta_description"`
	MetaKeywords        sql.NullString `json:"meta_keywords"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	Make                sql.NullString `json:"make"`
	Model               sql.NullString `json:"model"`
	Year                sql.NullInt64  `json:"year"`
	VehicleSlug         sql.NullString `json:"vehicle_slug"`
}

func (q *Queries) ListFeaturedJobs(ctx context.Context, limit int64) ([]ListFeaturedJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeaturedJobsRow
	for rows.Next() {
		var i ListFeaturedJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.VehicleID,
			&i.PackageID,
			&i.Technician,
			&i.Notes,
			&i.CompletedAt,
			&i.DurationActual,
			&i.Featured,
			&i.DisplayPrice,
			&i.HighlightText,
			&i.CustomerTestimonial,
			&i.CustomerName,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.VehicleSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedReviews = `-- name: ListFeaturedReviews :many
SELECT id, author, rating, body, source, is_featured, created_at FROM reviews
WHERE is_featured = 1
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListFeaturedReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Rating,
			&i.Body,
			&i.Source,
			&i.IsFeatured,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJobs = `-- name: ListJobs :many
SELECT j.id, j.slug, j.vehicle_id, j.package_id, j.technician, j.notes, j.completed_at, j.duration_actual, j.featured, j.display_price, j.highlight_text, j.customer_testimonial, j.customer_name, j.meta_description, j.meta_keywords, j.created_at, j.updated_at, v.make, v.model, v.year, v.slug as vehicle_slug
FROM jobs j
LEFT JOIN vehicles v ON j.vehicle_id = v.id
ORDER BY j.completed_at DESC
LIMIT ? OFFSET ?
`

type ListJobsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListJobsRow struct {
	ID                  int64          `json:"id"`
	Slug                sql.NullString `json:"slug"`
	VehicleID           sql.NullInt64  `json:"vehicle_id"`
	PackageID           sql.NullInt64  `json:"package_id"`
	Technician          sql.NullString `json:"technician"`
	Notes               sql.NullString `json:"notes"`
	CompletedAt         sql.NullTime   `json:"completed_at"`
	DurationActual      sql.NullInt64  `json:"duration_actual"`
	Featured            sql.NullBool   `json:"featured"`
	DisplayPrice        sql.NullInt64  `json:"display_price"`
	HighlightText       sql.NullString `json:"highlight_text"`
	CustomerTestimonial sql.NullString `json:"customer_testimonial"`
	CustomerName        sql.NullString `json:"customer_name"`
	MetaDescription     sql.NullString `json:"meta_description"`
	MetaKeywords        sql.NullString `json:"meta_keywords"`
	CreatedAt           sql.NullTime   `json:"created_at"`
	UpdatedAt           sql.NullTime   `json:"updated_at"`
	Make                sql.NullString `json:"make"`
	Model               sql.NullString `json:"model"`
	Year                sql.NullInt64  `json:"year"`
	VehicleSlug         sql.NullString `json:"vehicle_slug"`
}

func (q *Queries) ListJobs(ctx context.Context, arg ListJobsParams) ([]ListJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListJobsRow
	for rows.Next() {
		var i ListJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.VehicleID,
			&i.PackageID,
			&i.Technician,
			&i.Notes,
			&i.CompletedAt,
			&i.DurationActual,
			&i.Featured,
			&i.DisplayPrice,
			&i.HighlightText,
			&i.CustomerTestimonial,
			&i.CustomerName,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.VehicleSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
SELECT id, slug, title, excerpt, body, author, published_at, created_at, updated_at FROM posts
WHERE published_at IS NOT NULL
ORDER BY published_at DESC
LIMIT ? OFFSET ?
`

type ListPostsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, listPosts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.Excerpt,
			&i.Body,
			&i.Author,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviews = `-- name: ListReviews :many
SELECT id, author, rating, body, source, is_featured, created_at FROM reviews
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, listReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Rating,
			&i.Body,
			&i.Source,
			&i.IsFeatured,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePackage = `-- name: UpdatePackage :one
UPDATE packages
SET slug = ?, name = ?, short_desc = ?, long_desc = ?, price_min = ?, price_max = ?, duration_est = ?, is_active = ?, sort_order = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at
`

type UpdatePackageParams struct {
	Slug        string         `json:"slug"`
	Name        string         `json:"name"`
	ShortDesc   sql.NullString `json:"short_desc"`
	LongDesc    sql.NullString `json:"long_desc"`
	PriceMin    sql.NullInt64  `json:"price_min"`
	PriceMax    sql.NullInt64  `json:"price_max"`
	DurationEst sql.NullInt64  `json:"duration_est"`
	IsActive    sql.NullBool   `json:"is_active"`
	SortOrder   sql.NullInt64  `json:"sort_order"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdatePackage(ctx context.Context, arg UpdatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, updatePackage,
		arg.Slug,
		arg.Name,
		arg.ShortDesc,
		arg.LongDesc,
		arg.PriceMin,
		arg.PriceMax,
		arg.DurationEst,
		arg.IsActive,
		arg.SortOrder,
		arg.ID,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
