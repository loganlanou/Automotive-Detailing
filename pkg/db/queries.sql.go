// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countBlockedSlotsAt = `-- name: CountBlockedSlotsAt :one
SELECT COUNT(*)
FROM bookings
WHERE requested_start = ?
  AND status IN ('pending', 'confirmed')
`

func (q *Queries) CountBlockedSlotsAt(ctx context.Context, requestedStart time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBlockedSlotsAt, requestedStart)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBookings = `-- name: CountBookings :one
SELECT COUNT(*) FROM bookings
`

func (q *Queries) CountBookings(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookings)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBookingsByStatus = `-- name: CountBookingsByStatus :one
SELECT COUNT(*) FROM bookings
WHERE status = ?
`

func (q *Queries) CountBookingsByStatus(ctx context.Context, status sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookingsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGalleryGroups = `-- name: CountGalleryGroups :one
SELECT COUNT(*) FROM gallery_groups
`

func (q *Queries) CountGalleryGroups(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countGalleryGroups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMedia = `-- name: CountMedia :one
SELECT COUNT(*) FROM media
`

func (q *Queries) CountMedia(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMedia)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPackages = `-- name: CountPackages :one
SELECT COUNT(*) FROM packages
`

func (q *Queries) CountPackages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPackages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReviews = `-- name: CountReviews :one
SELECT COUNT(*) FROM reviews
`

func (q *Queries) CountReviews(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countReviews)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (
    customer_name,
    email,
    phone,
    vehicle_details,
    service_interest,
    notes,
    requested_start,
    requested_end,
    status,
    source,
    clerk_user_id
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, customer_name, email, phone, vehicle_details, service_interest, notes, requested_start, requested_end, status, source, internal_notes, clerk_user_id, created_at, updated_at
`

type CreateBookingParams struct {
	CustomerName    string         `json:"customer_name"`
	Email           string         `json:"email"`
	Phone           sql.NullString `json:"phone"`
	VehicleDetails  sql.NullString `json:"vehicle_details"`
	ServiceInterest sql.NullString `json:"service_interest"`
	Notes           sql.NullString `json:"notes"`
	RequestedStart  time.Time      `json:"requested_start"`
	RequestedEnd    time.Time      `json:"requested_end"`
	Status          sql.NullString `json:"status"`
	Source          sql.NullString `json:"source"`
	ClerkUserID     sql.NullString `json:"clerk_user_id"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (Booking, error) {
	row := q.db.QueryRowContext(ctx, createBooking,
		arg.CustomerName,
		arg.Email,
		arg.Phone,
		arg.VehicleDetails,
		arg.ServiceInterest,
		arg.Notes,
		arg.RequestedStart,
		arg.RequestedEnd,
		arg.Status,
		arg.Source,
		arg.ClerkUserID,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.Email,
		&i.Phone,
		&i.VehicleDetails,
		&i.ServiceInterest,
		&i.Notes,
		&i.RequestedStart,
		&i.RequestedEnd,
		&i.Status,
		&i.Source,
		&i.InternalNotes,
		&i.ClerkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGalleryGroup = `-- name: CreateGalleryGroup :one
INSERT INTO gallery_groups (title, slug, vehicle_make, vehicle_model, vehicle_year, description, is_featured, sort_order)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, slug, vehicle_make, vehicle_model, vehicle_year, description, is_featured, sort_order, created_at, updated_at
`

type CreateGalleryGroupParams struct {
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	VehicleMake  sql.NullString `json:"vehicle_make"`
	VehicleModel sql.NullString `json:"vehicle_model"`
	VehicleYear  sql.NullInt64  `json:"vehicle_year"`
	Description  sql.NullString `json:"description"`
	IsFeatured   sql.NullBool   `json:"is_featured"`
	SortOrder    sql.NullInt64  `json:"sort_order"`
}

func (q *Queries) CreateGalleryGroup(ctx context.Context, arg CreateGalleryGroupParams) (GalleryGroup, error) {
	row := q.db.QueryRowContext(ctx, createGalleryGroup,
		arg.Title,
		arg.Slug,
		arg.VehicleMake,
		arg.VehicleModel,
		arg.VehicleYear,
		arg.Description,
		arg.IsFeatured,
		arg.SortOrder,
	)
	var i GalleryGroup
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleYear,
		&i.Description,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMedia = `-- name: CreateMedia :one
INSERT INTO media (gallery_group_id, url, kind, sort_order, alt_text)
VALUES (?, ?, ?, ?, ?)
RETURNING id, gallery_group_id, url, kind, sort_order, alt_text, created_at
`

type CreateMediaParams struct {
	GalleryGroupID sql.NullInt64  `json:"gallery_group_id"`
	Url            string         `json:"url"`
	Kind           sql.NullString `json:"kind"`
	SortOrder      sql.NullInt64  `json:"sort_order"`
	AltText        sql.NullString `json:"alt_text"`
}

func (q *Queries) CreateMedia(ctx context.Context, arg CreateMediaParams) (Medium, error) {
	row := q.db.QueryRowContext(ctx, createMedia,
		arg.GalleryGroupID,
		arg.Url,
		arg.Kind,
		arg.SortOrder,
		arg.AltText,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.GalleryGroupID,
		&i.Url,
		&i.Kind,
		&i.SortOrder,
		&i.AltText,
		&i.CreatedAt,
	)
	return i, err
}

const createPackage = `-- name: CreatePackage :one
INSERT INTO packages (slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at
`

type CreatePackageParams struct {
	Slug        string         `json:"slug"`
	Name        string         `json:"name"`
	ShortDesc   sql.NullString `json:"short_desc"`
	LongDesc    sql.NullString `json:"long_desc"`
	PriceMin    sql.NullInt64  `json:"price_min"`
	PriceMax    sql.NullInt64  `json:"price_max"`
	DurationEst sql.NullInt64  `json:"duration_est"`
	IsActive    sql.NullBool   `json:"is_active"`
	SortOrder   sql.NullInt64  `json:"sort_order"`
}

func (q *Queries) CreatePackage(ctx context.Context, arg CreatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, createPackage,
		arg.Slug,
		arg.Name,
		arg.ShortDesc,
		arg.LongDesc,
		arg.PriceMin,
		arg.PriceMax,
		arg.DurationEst,
		arg.IsActive,
		arg.SortOrder,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (author, rating, body, source, is_featured)
VALUES (?, ?, ?, ?, ?)
RETURNING id, author, rating, body, source, is_featured, created_at
`

type CreateReviewParams struct {
	Author     string         `json:"author"`
	Rating     sql.NullInt64  `json:"rating"`
	Body       sql.NullString `json:"body"`
	Source     sql.NullString `json:"source"`
	IsFeatured sql.NullBool   `json:"is_featured"`
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (Review, error) {
	row := q.db.QueryRowContext(ctx, createReview,
		arg.Author,
		arg.Rating,
		arg.Body,
		arg.Source,
		arg.IsFeatured,
	)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.Author,
		&i.Rating,
		&i.Body,
		&i.Source,
		&i.IsFeatured,
		&i.CreatedAt,
	)
	return i, err
}

const deleteGalleryGroup = `-- name: DeleteGalleryGroup :exec
DELETE FROM gallery_groups WHERE id = ?
`

func (q *Queries) DeleteGalleryGroup(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteGalleryGroup, id)
	return err
}

const deleteMedia = `-- name: DeleteMedia :exec
DELETE FROM media WHERE id = ?
`

func (q *Queries) DeleteMedia(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMedia, id)
	return err
}

const deletePackage = `-- name: DeletePackage :exec
DELETE FROM packages WHERE id = ?
`

func (q *Queries) DeletePackage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePackage, id)
	return err
}

const deleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews WHERE id = ?
`

func (q *Queries) DeleteReview(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteReview, id)
	return err
}

const getAllPackages = `-- name: GetAllPackages :many

SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE is_active = 1
ORDER BY sort_order, id
`

// Package queries
func (q *Queries) GetAllPackages(ctx context.Context) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, getAllPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.ShortDesc,
			&i.LongDesc,
			&i.PriceMin,
			&i.PriceMax,
			&i.DurationEst,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPackagesAdmin = `-- name: GetAllPackagesAdmin :many
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
ORDER BY sort_order, id
`

func (q *Queries) GetAllPackagesAdmin(ctx context.Context) ([]Package, error) {
	rows, err := q.db.QueryContext(ctx, getAllPackagesAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.ShortDesc,
			&i.LongDesc,
			&i.PriceMin,
			&i.PriceMax,
			&i.DurationEst,
			&i.IsActive,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT id, customer_name, email, phone, vehicle_details, service_interest, notes, requested_start, requested_end, status, source, internal_notes, clerk_user_id, created_at, updated_at FROM bookings
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBookingByID(ctx context.Context, id int64) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getBookingByID, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.Email,
		&i.Phone,
		&i.VehicleDetails,
		&i.ServiceInterest,
		&i.Notes,
		&i.RequestedStart,
		&i.RequestedEnd,
		&i.Status,
		&i.Source,
		&i.InternalNotes,
		&i.ClerkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGalleryGroupByID = `-- name: GetGalleryGroupByID :one
SELECT id, title, slug, vehicle_make, vehicle_model, vehicle_year, description, is_featured, sort_order, created_at, updated_at FROM gallery_groups
WHERE id = ? LIMIT 1
`

func (q *Queries) GetGalleryGroupByID(ctx context.Context, id int64) (GalleryGroup, error) {
	row := q.db.QueryRowContext(ctx, getGalleryGroupByID, id)
	var i GalleryGroup
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleYear,
		&i.Description,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGalleryGroupBySlug = `-- name: GetGalleryGroupBySlug :one
SELECT id, title, slug, vehicle_make, vehicle_model, vehicle_year, description, is_featured, sort_order, created_at, updated_at FROM gallery_groups
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetGalleryGroupBySlug(ctx context.Context, slug string) (GalleryGroup, error) {
	row := q.db.QueryRowContext(ctx, getGalleryGroupBySlug, slug)
	var i GalleryGroup
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleYear,
		&i.Description,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHeroImageForGalleryGroup = `-- name: GetHeroImageForGalleryGroup :one
SELECT id, gallery_group_id, url, kind, sort_order, alt_text, created_at FROM media
WHERE gallery_group_id = ? AND kind = 'hero'
ORDER BY sort_order
LIMIT 1
`

func (q *Queries) GetHeroImageForGalleryGroup(ctx context.Context, galleryGroupID sql.NullInt64) (Medium, error) {
	row := q.db.QueryRowContext(ctx, getHeroImageForGalleryGroup, galleryGroupID)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.GalleryGroupID,
		&i.Url,
		&i.Kind,
		&i.SortOrder,
		&i.AltText,
		&i.CreatedAt,
	)
	return i, err
}

const getMediaForGalleryGroup = `-- name: GetMediaForGalleryGroup :many

SELECT id, gallery_group_id, url, kind, sort_order, alt_text, created_at FROM media
WHERE gallery_group_id = ?
ORDER BY sort_order, id
`

// Media queries
func (q *Queries) GetMediaForGalleryGroup(ctx context.Context, galleryGroupID sql.NullInt64) ([]Medium, error) {
	rows, err := q.db.QueryContext(ctx, getMediaForGalleryGroup, galleryGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.GalleryGroupID,
			&i.Url,
			&i.Kind,
			&i.SortOrder,
			&i.AltText,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPackageByID = `-- name: GetPackageByID :one
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE id = ? LIMIT 1
`

func (q *Queries) GetPackageByID(ctx context.Context, id int64) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageByID, id)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPackageBySlug = `-- name: GetPackageBySlug :one
SELECT id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at FROM packages
WHERE slug = ? LIMIT 1
`

func (q *Queries) GetPackageBySlug(ctx context.Context, slug string) (Package, error) {
	row := q.db.QueryRowContext(ctx, getPackageBySlug, slug)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBlockedSlots = `-- name: ListBlockedSlots :many
SELECT requested_start, requested_end, status
FROM bookings
WHERE requested_start >= ?
  AND requested_start < ?
  AND status IN ('pending', 'confirmed')
ORDER BY requested_start
`

type ListBlockedSlotsParams struct {
	RequestedStart   time.Time `json:"requested_start"`
	RequestedStart_2 time.Time `json:"requested_start_2"`
}

type ListBlockedSlotsRow struct {
	RequestedStart time.Time      `json:"requested_start"`
	RequestedEnd   time.Time      `json:"requested_end"`
	Status         sql.NullString `json:"status"`
}

func (q *Queries) ListBlockedSlots(ctx context.Context, arg ListBlockedSlotsParams) ([]ListBlockedSlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, listBlockedSlots, arg.RequestedStart, arg.RequestedStart_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBlockedSlotsRow
	for rows.Next() {
		var i ListBlockedSlotsRow
		if err := rows.Scan(&i.RequestedStart, &i.RequestedEnd, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookings = `-- name: ListBookings :many

SELECT id, customer_name, email, phone, vehicle_details, service_interest, notes, requested_start, requested_end, status, source, internal_notes, clerk_user_id, created_at, updated_at FROM bookings
ORDER BY requested_start DESC
LIMIT ? OFFSET ?
`

type ListBookingsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Booking queries
func (q *Queries) ListBookings(ctx context.Context, arg ListBookingsParams) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, listBookings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.Email,
			&i.Phone,
			&i.VehicleDetails,
			&i.ServiceInterest,
			&i.Notes,
			&i.RequestedStart,
			&i.RequestedEnd,
			&i.Status,
			&i.Source,
			&i.InternalNotes,
			&i.ClerkUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByStatus = `-- name: ListBookingsByStatus :many
SELECT id, customer_name, email, phone, vehicle_details, service_interest, notes, requested_start, requested_end, status, source, internal_notes, clerk_user_id, created_at, updated_at FROM bookings
WHERE status = ?
ORDER BY requested_start ASC
LIMIT ? OFFSET ?
`

type ListBookingsByStatusParams struct {
	Status sql.NullString `json:"status"`
	Limit  int64          `json:"limit"`
	Offset int64          `json:"offset"`
}

func (q *Queries) ListBookingsByStatus(ctx context.Context, arg ListBookingsByStatusParams) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, listBookingsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.Email,
			&i.Phone,
			&i.VehicleDetails,
			&i.ServiceInterest,
			&i.Notes,
			&i.RequestedStart,
			&i.RequestedEnd,
			&i.Status,
			&i.Source,
			&i.InternalNotes,
			&i.ClerkUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsForCalendar = `-- name: ListBookingsForCalendar :many
SELECT id, customer_name, email, phone, vehicle_details, service_interest, requested_start, requested_end, status
FROM bookings
WHERE requested_start >= ?
  AND requested_start < ?
ORDER BY requested_start ASC
`

type ListBookingsForCalendarParams struct {
	RequestedStart   time.Time `json:"requested_start"`
	RequestedStart_2 time.Time `json:"requested_start_2"`
}

type ListBookingsForCalendarRow struct {
	ID              int64          `json:"id"`
	CustomerName    string         `json:"customer_name"`
	Email           string         `json:"email"`
	Phone           sql.NullString `json:"phone"`
	VehicleDetails  sql.NullString `json:"vehicle_details"`
	ServiceInterest sql.NullString `json:"service_interest"`
	RequestedStart  time.Time      `json:"requested_start"`
	RequestedEnd    time.Time      `json:"requested_end"`
	Status          sql.NullString `json:"status"`
}

func (q *Queries) ListBookingsForCalendar(ctx context.Context, arg ListBookingsForCalendarParams) ([]ListBookingsForCalendarRow, error) {
	rows, err := q.db.QueryContext(ctx, listBookingsForCalendar, arg.RequestedStart, arg.RequestedStart_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBookingsForCalendarRow
	for rows.Next() {
		var i ListBookingsForCalendarRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.Email,
			&i.Phone,
			&i.VehicleDetails,
			&i.ServiceInterest,
			&i.RequestedStart,
			&i.RequestedEnd,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedGalleryGroups = `-- name: ListFeaturedGalleryGroups :many
SELECT id, title, slug, vehicle_make, vehicle_model, vehicle_year, description, is_featured, sort_order, created_at, updated_at FROM gallery_groups
WHERE is_featured = 1
ORDER BY sort_order, created_at DESC
LIMIT ?
`

func (q *Queries) ListFeaturedGalleryGroups(ctx context.Context, limit int64) ([]GalleryGroup, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedGalleryGroups, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GalleryGroup
	for rows.Next() {
		var i GalleryGroup
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.VehicleYear,
			&i.Description,
			&i.IsFeatured,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedReviews = `-- name: ListFeaturedReviews :many
SELECT id, author, rating, body, source, is_featured, created_at FROM reviews
WHERE is_featured = 1
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListFeaturedReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Rating,
			&i.Body,
			&i.Source,
			&i.IsFeatured,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGalleryGroups = `-- name: ListGalleryGroups :many

SELECT id, title, slug, vehicle_make, vehicle_model, vehicle_year, description, is_featured, sort_order, created_at, updated_at FROM gallery_groups
ORDER BY sort_order, created_at DESC
LIMIT ? OFFSET ?
`

type ListGalleryGroupsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Gallery queries
func (q *Queries) ListGalleryGroups(ctx context.Context, arg ListGalleryGroupsParams) ([]GalleryGroup, error) {
	rows, err := q.db.QueryContext(ctx, listGalleryGroups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GalleryGroup
	for rows.Next() {
		var i GalleryGroup
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.VehicleMake,
			&i.VehicleModel,
			&i.VehicleYear,
			&i.Description,
			&i.IsFeatured,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReviews = `-- name: ListReviews :many

SELECT id, author, rating, body, source, is_featured, created_at FROM reviews
ORDER BY created_at DESC
LIMIT ?
`

// Review queries
func (q *Queries) ListReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, listReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.Author,
			&i.Rating,
			&i.Body,
			&i.Source,
			&i.IsFeatured,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingBookings = `-- name: ListUpcomingBookings :many
SELECT id, customer_name, email, phone, vehicle_details, service_interest, notes, requested_start, requested_end, status, source, internal_notes, clerk_user_id, created_at, updated_at FROM bookings
WHERE requested_start >= datetime('now')
  AND status IN ('pending', 'confirmed')
ORDER BY requested_start ASC
LIMIT ?
`

func (q *Queries) ListUpcomingBookings(ctx context.Context, limit int64) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, listUpcomingBookings, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.Email,
			&i.Phone,
			&i.VehicleDetails,
			&i.ServiceInterest,
			&i.Notes,
			&i.RequestedStart,
			&i.RequestedEnd,
			&i.Status,
			&i.Source,
			&i.InternalNotes,
			&i.ClerkUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookingStatus = `-- name: UpdateBookingStatus :one
UPDATE bookings
SET status = ?, internal_notes = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, customer_name, email, phone, vehicle_details, service_interest, notes, requested_start, requested_end, status, source, internal_notes, clerk_user_id, created_at, updated_at
`

type UpdateBookingStatusParams struct {
	Status        sql.NullString `json:"status"`
	InternalNotes sql.NullString `json:"internal_notes"`
	ID            int64          `json:"id"`
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) (Booking, error) {
	row := q.db.QueryRowContext(ctx, updateBookingStatus, arg.Status, arg.InternalNotes, arg.ID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.Email,
		&i.Phone,
		&i.VehicleDetails,
		&i.ServiceInterest,
		&i.Notes,
		&i.RequestedStart,
		&i.RequestedEnd,
		&i.Status,
		&i.Source,
		&i.InternalNotes,
		&i.ClerkUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGalleryGroup = `-- name: UpdateGalleryGroup :one
UPDATE gallery_groups
SET title = ?, slug = ?, vehicle_make = ?, vehicle_model = ?, vehicle_year = ?, description = ?, is_featured = ?, sort_order = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, title, slug, vehicle_make, vehicle_model, vehicle_year, description, is_featured, sort_order, created_at, updated_at
`

type UpdateGalleryGroupParams struct {
	Title        string         `json:"title"`
	Slug         string         `json:"slug"`
	VehicleMake  sql.NullString `json:"vehicle_make"`
	VehicleModel sql.NullString `json:"vehicle_model"`
	VehicleYear  sql.NullInt64  `json:"vehicle_year"`
	Description  sql.NullString `json:"description"`
	IsFeatured   sql.NullBool   `json:"is_featured"`
	SortOrder    sql.NullInt64  `json:"sort_order"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateGalleryGroup(ctx context.Context, arg UpdateGalleryGroupParams) (GalleryGroup, error) {
	row := q.db.QueryRowContext(ctx, updateGalleryGroup,
		arg.Title,
		arg.Slug,
		arg.VehicleMake,
		arg.VehicleModel,
		arg.VehicleYear,
		arg.Description,
		arg.IsFeatured,
		arg.SortOrder,
		arg.ID,
	)
	var i GalleryGroup
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.VehicleMake,
		&i.VehicleModel,
		&i.VehicleYear,
		&i.Description,
		&i.IsFeatured,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMedia = `-- name: UpdateMedia :one
UPDATE media
SET url = ?, kind = ?, sort_order = ?, alt_text = ?
WHERE id = ?
RETURNING id, gallery_group_id, url, kind, sort_order, alt_text, created_at
`

type UpdateMediaParams struct {
	Url       string         `json:"url"`
	Kind      sql.NullString `json:"kind"`
	SortOrder sql.NullInt64  `json:"sort_order"`
	AltText   sql.NullString `json:"alt_text"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateMedia(ctx context.Context, arg UpdateMediaParams) (Medium, error) {
	row := q.db.QueryRowContext(ctx, updateMedia,
		arg.Url,
		arg.Kind,
		arg.SortOrder,
		arg.AltText,
		arg.ID,
	)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.GalleryGroupID,
		&i.Url,
		&i.Kind,
		&i.SortOrder,
		&i.AltText,
		&i.CreatedAt,
	)
	return i, err
}

const updatePackage = `-- name: UpdatePackage :one
UPDATE packages
SET slug = ?, name = ?, short_desc = ?, long_desc = ?, price_min = ?, price_max = ?, duration_est = ?, is_active = ?, sort_order = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, slug, name, short_desc, long_desc, price_min, price_max, duration_est, is_active, sort_order, created_at, updated_at
`

type UpdatePackageParams struct {
	Slug        string         `json:"slug"`
	Name        string         `json:"name"`
	ShortDesc   sql.NullString `json:"short_desc"`
	LongDesc    sql.NullString `json:"long_desc"`
	PriceMin    sql.NullInt64  `json:"price_min"`
	PriceMax    sql.NullInt64  `json:"price_max"`
	DurationEst sql.NullInt64  `json:"duration_est"`
	IsActive    sql.NullBool   `json:"is_active"`
	SortOrder   sql.NullInt64  `json:"sort_order"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdatePackage(ctx context.Context, arg UpdatePackageParams) (Package, error) {
	row := q.db.QueryRowContext(ctx, updatePackage,
		arg.Slug,
		arg.Name,
		arg.ShortDesc,
		arg.LongDesc,
		arg.PriceMin,
		arg.PriceMax,
		arg.DurationEst,
		arg.IsActive,
		arg.SortOrder,
		arg.ID,
	)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.ShortDesc,
		&i.LongDesc,
		&i.PriceMin,
		&i.PriceMax,
		&i.DurationEst,
		&i.IsActive,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
